## ForkJoin
1. ForkJoin是Java7提供的一个并行执行任务的框架，是把大任务分割成若干个小任务，待小任务完成后将结果汇总成大任务结果的框架。
主要采用的是工作窃取算法，工作窃取算法是指某个线程从其他队列里窃取任务来执行。
2. 在窃取过程中两个线程会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常我们会使用双端队列来实现工作窃取算法。
被窃取任务的线程永远从队列的头部拿取任务，窃取任务的线程从队列尾部拿取任务。

### 局限性
1. 任务只能使用fork和join作为同步机制，如果使用了其他同步机制，当他们在同步操作时，工作线程就不能执行其他任务了。比如在fork框架使任务进入了睡眠，那么在睡眠期间内在执行这个任务的线程将不会执行其他任务了。 
2. 我们所拆分的任务不应该去执行IO操作，如读和写数据文件。 
3. 任务不能抛出检查异常。必须通过必要的代码来处理他们。

### 框架核心
核心有两个类：ForkJoinPool | ForkJoinTask 
ForkJoinPool：负责来做实现，包括工作窃取算法、管理工作线程和提供关于任务的状态以及他们的执行信息。 
ForkJoinTask:提供在任务中执行fork和join的机制。

## BlockingQueue阻塞队列
主要应用场景：生产者消费者模型，是线程安全的
### 四套方法
BlockingQueue提供了四套方法，分别来进行插入、移除、检查。每套方法在不能立刻执行时都有不同的反应。  
- Throws Exceptions ：如果不能立即执行就抛出异常。
- Special Value：如果不能立即执行就返回一个特殊的值。
- Blocks：如果不能立即执行就阻塞。
- Times Out：如果不能立即执行就阻塞一段时间，如果过了设定时间还没有被执行，则返回一个值。

### 实现类
1. ArrayBlockingQueue：它是一个有界的阻塞队列，内部实现是数组，初始化时指定容量大小，一旦指定大小就不能再变。采用FIFO方式存储元素。
2. DelayQueue：阻塞内部元素，内部元素必须实现Delayed接口，Delayed接口又继承了Comparable接口，原因在于DelayQueue内部元素需要排序，一般情况按过期时间优先级排序。
3. LinkedBlockingQueue：大小配置可选，如果初始化时指定了大小，那么它就是有边界的。不指定就无边界（最大整型值）。内部实现是链表，采用FIFO形式保存数据。
4. PriorityBlockingQueue:带优先级的阻塞队列。无边界队列，允许插入null。插入的对象必须实现Comparator接口，队列优先级的排序规则就是按照我们对Comparable接口的实现来指定的。我们可以从PriorityBlockingQueue中获取一个迭代器，但这个迭代器并不保证能按照优先级的顺序进行迭代。
5. SynchronusQueue：只能插入一个元素，同步队列，无界非缓存队列，不存储元素。

